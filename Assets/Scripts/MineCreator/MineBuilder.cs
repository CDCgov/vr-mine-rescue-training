/*
 * Instantiates game objects to create a mine map from a given tileset and settings.
 */

using Google.Protobuf;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace NIOSH_MineCreation
{
    public class MineBuilder
    {
        #region variables
        // TODO: remove or better name since we will not just be using crosscuts
        private float sectionDistance;

        // The position to instantiate the next tile
        private Vector3 builderPosition = Vector3.zero;

        // Stored settings to reference throughout the build process
        private MineSettings loadedSettings;

        // Stored tileset to instantiate objects from throughout the build process
        private MineTileset loadedTileset;

        // Assets that are placed automatically at mine generation.
        private LoadableAssetCollection autoGeneratedAssets;

        // Scaling vector to use on each fourway section
        // TODO: remove or better name since we will not just be using crosscuts
        private Vector3 crossTileScaler;

        // GameObject to hold all the mine tiles
        //private GameObject mineObj;
        public List<RoofBoltGenerator> SpawnedRoofBoltGenerators;

        public delegate void OnBuildComplete();
        public event OnBuildComplete onBuildComplete;

        private Transform _parent;

        LoadableAssetManager _loadManager;

        #endregion


        /// <summary>
        /// Instantiate prefabs from the given tileset to create a mine that reflects the given settings.
        /// </summary>
        /// <param name="tileset">The tileset to instatiate the prefabs from</param>
        /// <param name="settings">The properties to scale the tiles to affect mine shape and size</param>
        public IEnumerator BuildMine(MineTileset tileset, LoadableAssetCollection collection, MineSettings settings, Transform parent)
        {
            builderPosition = Vector3.zero;

            _loadManager = LoadableAssetManager.GetDefault(null);

            // Store the tileset and settings for use throughout the build process
            loadedSettings = settings;
            loadedTileset = tileset;
            autoGeneratedAssets = collection;
            SpawnedRoofBoltGenerators = new List<RoofBoltGenerator>();
            // Get scaler values so we can quickly use them to transform the tiles we plan to instantiate
            DetermineSectionDistance(tileset.GetRandomFourwayTile(), settings.entryWidth, settings.seamHeight);

            // Clear the current mine if one is built
            //if (mineObj)
            //    Object.Destroy(mineObj);
            if (parent == null)
                yield return null;

            _parent = parent;

            foreach (Transform xform in parent)
            {
                GameObject.Destroy(xform.gameObject);
            }

            //mineObj =  GameObject.Find("Assets");
            //mineObj = new GameObject("MineParent");
            /* The mine is build from the entry row to the back. Each cross cut is a row and each row of the connecting
            *  straights is also a row we build separatly. So the total number of rows we build on is the number of
            *  crosscuts and then each row of the connecting straights, but there is always one less stright row than 
            *  crosscut rows*/
            yield return ConstructEndcaps(true);
            builderPosition.z -= (sectionDistance / 2.0f);
            builderPosition.x = 0;

            for (int i = 0; i < (settings.numCrosscuts * 2) - 1; i++)
            {
                // Alternate between making a crosscut and a row of just the straights connecting the crosscut tunnels
                if (i % 2 == 0)
                {// Make a crosscut
                    yield return ConstructCrosscut();

                    // Repossition for next row
                    if(i != (settings.numCrosscuts * 2) - 2)
                    {
                        builderPosition.z -= (sectionDistance / 2.0f) + ((settings.pillarLength - (sectionDistance / 2.0f)) / 2.0f);
                    }
                    else
                    {
                        builderPosition.z -= (sectionDistance / 2.0f);
                    }
                    builderPosition.x = 0;
                }
                else
                {// Make row of connecting straights
                    if(settings.pillarLength != settings.entryWidth)
                        yield return ConstructPillarSegment();

                    // Repossition for next row
                    builderPosition.z -= (sectionDistance / 2.0f) + ((settings.pillarLength - (sectionDistance / 2.0f)) / 2.0f);
                    builderPosition.x = 0;
                }
            }

            yield return ConstructEndcaps(false);

            // Reset builder at the starting position
            builderPosition = Vector3.zero;

            //MineLayerTile.BuildScaler = crossTileScaler;
            //MineLayerTile.Settings = loadedSettings;
            ScenarioSaveLoad.Settings.MineScale = crossTileScaler;
            ScenarioSaveLoad.Settings.MineSettings = loadedSettings;

            foreach(LoadableAsset autoGenAsset in autoGeneratedAssets.GetAllLoadableAssets())
            {

                //GameObject prefab = AssetLoader.Instance.GetPlaceableAsset(autoGenAsset.GetName());

                //if(prefab == null) { continue; }
                //GameObject obj;
                //Making exception for DM Spawn autogenerated asset to have it at a good height. -BDM

                Debug.Log($"Auto Gen Asset: {autoGenAsset.AssetID}");

                Quaternion rot;
                Vector3 pos;
                //if (autoGenAsset.GetName() == "DM Spawn Point")
                //{
                //    rot = Quaternion.Euler(30, 0, 0);
                //    pos = new Vector3(0, 3, -12);
                //    //obj = GameObject.Instantiate(prefab,
                //    //                                    new Vector3(0, 3, -12),
                //    //                                    rot,
                //    //                                    parent);
                //}
                //else
                //{
                //    rot = Quaternion.identity;
                //    pos = new Vector3(0, 0, -6);
                //    //obj = GameObject.Instantiate(prefab,
                //    //                                        new Vector3(0, 0, -6),
                //    //                                        Quaternion.identity,
                //    //                                        parent);
                //}

                rot = Quaternion.identity;
                pos = new Vector3(0, 0, -6);

                if (autoGenAsset.AssetID == "DM_SPAWN")
                {
                    rot = Quaternion.Euler(30, 0, 0);
                    pos = new Vector3(0, 3, -12);
                }

                var obj = _loadManager.InstantiateEditorAsset(autoGenAsset.AssetID, pos, rot, _parent);
                if (obj == null)
                    continue;

                // FIXME Need better placement of auto generated objects
                obj.name = autoGenAsset.AssetWindowName;
                PlacablePrefab spawnedPrefab = obj.GetComponent<PlacablePrefab>();

                if (spawnedPrefab == null)
                {
                    spawnedPrefab = obj.AddComponent<PlacablePrefab>();
                }

                obj.SetActive(true);
            }

            SetAllTilesPlaced();

            var manager = MineLayerTileManager.GetDefault();
            if (manager != null)
                manager.RebuildTileConnections();

            onBuildComplete?.Invoke();
        }

        void SetAllTilesPlaced()
        {
            var placeables = GameObject.FindObjectsOfType<PlacablePrefab>();

            foreach (var placeable in placeables)
            {
                if (placeable.isIgnoreSave) continue;

                if (!placeable.TryGetComponent<MineLayerTile>(out var mineLayerTile))
                    continue;

                mineLayerTile.SetReturnPoint(mineLayerTile.transform.position);
            }
        }


        #region Helper Functions
        /// <summary>
        /// Find the size difference between the fourway tile and user settings to determine the scaling vector needed
        /// to transform the tile to the user's desired size
        /// </summary>
        /// <param name="fourwayTile">The tile to base scaling from</param>
        /// <param name="entryWidth">The desired tunnel width</param>
        /// <param name="seamHeight">The desired tunnel height</param>
        private void DetermineSectionDistance(MineTile fourwayTile, float entryWidth, float seamHeight)
        {
            // Determining scale only works with a tile that has equal length to its width
            if (fourwayTile.tileLength != fourwayTile.tileWidth)
            {
                Debug.LogWarning("MineBuilder is using a tile that has a length different than its width! " +
                                 "This will cause the mine to be generated with impropper scaling of the tunnels!");
            }

            // Find the difference between the pieces we have and the desired tunnel width
            float scaleDifference = entryWidth / fourwayTile.entryWidth;

            // Store the scaler needed to transform the fourway sections to the desired size in the settings
            crossTileScaler = new Vector3(scaleDifference, seamHeight / fourwayTile.tileSeamHeight, scaleDifference);

            sectionDistance = fourwayTile.tileLength * scaleDifference;
        }

        private IEnumerator ConstructEndcaps(bool isNorth)
        {
            for (int i = 0; i < loadedSettings.numEntries; i++)
            {
                MakeEndcap(isNorth);

                // Reposition to place the next tile
                builderPosition.x -= sectionDistance + (loadedSettings.pillarWidth - (sectionDistance / 2.0f));

                if (i % 3 == 0)
                    yield return null;
            }
        }

        /// <summary>
        /// Instantiate the tiles to make a crosscut tunnel row
        /// </summary>
        private IEnumerator ConstructCrosscut()
        {
            List<RoofBoltGenerator> rbGs = new List<RoofBoltGenerator>();
            for (int i = 0; i < (loadedSettings.numEntries * 2) - 1; i++)
            {
                if (i == 0)
                {
                    MineTile newTile = loadedTileset.GetRandomEastTTile();

                    //GameObject newTTile = Object.Instantiate(newTile.tileObject,
                    //                   builderPosition,
                    //                   newTile.tileObject.transform.rotation,
                    //                   _parent);
                    var newTTile = _loadManager.InstantiateEditorAsset(newTile.TileAsset, null, builderPosition, Quaternion.identity, _parent);
                    newTTile.SetActive(true);
                    newTTile.name = newTile.tileObject.name;
                    // Scale the tile to match the size in the settings
                    newTTile.transform.localScale = crossTileScaler;
                    if (!newTTile.TryGetComponent<PlacablePrefab>(out var placeable))
                        newTTile.AddComponent<PlacablePrefab>();
                    RoofBoltGenerator rb = newTTile.GetComponent<RoofBoltGenerator>();
                    ComponentInfo_MineSegment cI_MS = newTTile.GetComponent<ComponentInfo_MineSegment>();
                    cI_MS.BoltSpacing = loadedSettings.BoltSpacing;
                    if(rb != null)
                    {
                        rb.RoofBoltSpacing = loadedSettings.BoltSpacing;
                        rb.BoltRibOffset = loadedSettings.BoltRibOffset;
                        Debug.Log($"Bolt space: {rb.RoofBoltSpacing}");
                        //yield return 0;
                        //rb.GenerateBolts();
                        rbGs.Add(rb);
                    }
                    
                }
                else if (i == (loadedSettings.numEntries * 2) - 2)
                {
                    MineTile newTile = loadedTileset.GetRandomWestTTile();

                    //GameObject newTTile = Object.Instantiate(newTile.tileObject,
                    //                   builderPosition,
                    //                   newTile.tileObject.transform.rotation,
                    //                   _parent);
                    var newTTile = _loadManager.InstantiateEditorAsset(newTile.TileAsset, null, builderPosition, Quaternion.identity, _parent);
                    newTTile.SetActive(true);
                    newTTile.name = newTile.tileObject.name;
                    // Scale the tile to match the size in the settings
                    newTTile.transform.localScale = crossTileScaler;
                    if (!newTTile.TryGetComponent<PlacablePrefab>(out var placeable))
                        newTTile.AddComponent<PlacablePrefab>();
                    RoofBoltGenerator rb = newTTile.GetComponent<RoofBoltGenerator>();
                    ComponentInfo_MineSegment cI_MS = newTTile.GetComponent<ComponentInfo_MineSegment>();
                    cI_MS.BoltSpacing = loadedSettings.BoltSpacing;
                    if (rb != null)
                    {
                        rb.RoofBoltSpacing = loadedSettings.BoltSpacing;
                        rb.BoltRibOffset = loadedSettings.BoltRibOffset;
                        //rb.GenerateBolts();
                        rbGs.Add(rb);
                    }
                }
                else if (i % 2 == 0)
                {// Make a fourway tile
                    MineTile newTile = loadedTileset.GetRandomFourwayTile();

                    //GameObject new4Way = Object.Instantiate(newTile.tileObject,
                    //                   builderPosition,
                    //                   newTile.tileObject.transform.rotation,
                    //                   _parent);
                    var new4Way = _loadManager.InstantiateEditorAsset(newTile.TileAsset, null, builderPosition, Quaternion.identity, _parent);
                    new4Way.SetActive(true);
                    new4Way.name = newTile.tileObject.name;
                    // Scale the tile to match the size in the settings
                    new4Way.transform.localScale = crossTileScaler;
                    if (!new4Way.TryGetComponent<PlacablePrefab>(out var placeable))
                        new4Way.AddComponent<PlacablePrefab>();
                    RoofBoltGenerator rb = new4Way.GetComponent<RoofBoltGenerator>();
                    ComponentInfo_MineSegment cI_MS = new4Way.GetComponent<ComponentInfo_MineSegment>();
                    cI_MS.BoltSpacing = loadedSettings.BoltSpacing;
                    if (rb != null)
                    {
                        rb.RoofBoltSpacing = loadedSettings.BoltSpacing;
                        rb.BoltRibOffset = loadedSettings.BoltRibOffset;
                        //rb.GenerateBolts();
                        rbGs.Add(rb);
                    }
                }
                else
                {// Make the connecting tunnel between fourway sections
                    if(loadedSettings.pillarWidth != loadedSettings.entryWidth)
                        MakeEWPillar();
                }
                // Reposition to place the next tile
                builderPosition.x -= (sectionDistance / 2.0f) + ((loadedSettings.pillarWidth - (sectionDistance / 2.0f)) / 2.0f);
                yield return 0;
                if(rbGs.Count > 0)
                {
                    foreach (var rb in rbGs)
                    {
                        //rb.GenerateBolts();
                        //StartCoroutine(DelayedBoltSpawner(rb));
                        rb.RoofBoltSpacing = loadedSettings.BoltSpacing;
                        rb.BoltRibOffset = loadedSettings.BoltRibOffset;
                        SpawnedRoofBoltGenerators.Add(rb);
                    }
                }
                if(i % 3 == 0)
                    yield return null;
            }
        }

        

        /// <summary>
        /// Instantiate the row of straight tunnels that connect the crosscut rows
        /// </summary>
        private IEnumerator ConstructPillarSegment()
        {
            for (int i = 0; i < loadedSettings.numEntries; i++)
            {
                MakeNSPillar();

                // Reposition to place the next tile
                builderPosition.x -= sectionDistance + (loadedSettings.pillarWidth - (sectionDistance / 2.0f));

                if (i % 3 == 0)
                    yield return null;
            }
        }

        private void MakeEWPillar()
        {
            // Pick random tile
            MineTile pillarTile = loadedTileset.GetRandomStraightEWTile();
            List<RoofBoltGenerator> rbGs = new List<RoofBoltGenerator>();


            Vector3 pillarScaler = new Vector3((loadedSettings.pillarWidth - (sectionDistance / 2.0f)) / pillarTile.tileWidth,
                                               loadedSettings.seamHeight / pillarTile.tileSeamHeight,
                                               loadedSettings.entryWidth / pillarTile.tileLength);

            //GameObject newPillar = Object.Instantiate(pillarTile.tileObject,
            //                           builderPosition,
            //                           pillarTile.tileObject.transform.rotation,
            //                           _parent);
            var newPillar = _loadManager.InstantiateEditorAsset(pillarTile.TileAsset, null, builderPosition, Quaternion.identity, _parent);
            newPillar.SetActive(true);
            newPillar.name = pillarTile.tileObject.name;
            if (!newPillar.TryGetComponent<PlacablePrefab>(out var placeable))
                newPillar.AddComponent<PlacablePrefab>();
            newPillar.transform.localScale = pillarScaler;
            RoofBoltGenerator rb = newPillar.GetComponent<RoofBoltGenerator>();
            ComponentInfo_MineSegment cI_MS = newPillar.GetComponent<ComponentInfo_MineSegment>();
            cI_MS.BoltSpacing = loadedSettings.BoltSpacing;
            if (rb != null)
            {
                rb.RoofBoltSpacing = loadedSettings.BoltSpacing;
                rb.BoltRibOffset = loadedSettings.BoltRibOffset;
                //rb.GenerateBolts();
                rbGs.Add(rb);
            }

            //yield return 0;
            foreach (var gen in rbGs)
            {
                //gen.GenerateBolts();
                gen.RoofBoltSpacing = loadedSettings.BoltSpacing;
                gen.BoltRibOffset = loadedSettings.BoltRibOffset;
                SpawnedRoofBoltGenerators.Add(gen);
            }
            //trying to make autoteamstop selection - BDM
            if (newPillar.transform.localScale.x < 1)
            {
                ComponentInfo_MineSegment ms = newPillar.GetComponent<ComponentInfo_MineSegment>();
                if(ms != null)
                {
                    ms.IsTeamstop = false;
                }
            }
        }

        private void MakeNSPillar()
        {
            // Pick random tile
            MineTile pillarTile = loadedTileset.GetRandomStraightNSTile();
            List<RoofBoltGenerator> rbGs = new List<RoofBoltGenerator>();

            Vector3 pillarScaler = new Vector3(loadedSettings.entryWidth / pillarTile.tileWidth,
                                               loadedSettings.seamHeight / pillarTile.tileSeamHeight,
                                               (loadedSettings.pillarLength - (sectionDistance / 2.0f)) / pillarTile.tileLength);

            //GameObject newPillar = Object.Instantiate(pillarTile.tileObject,
            //                           builderPosition,
            //                           pillarTile.tileObject.transform.rotation,
            //                           _parent);
            var newPillar = _loadManager.InstantiateEditorAsset(pillarTile.TileAsset, null, builderPosition, Quaternion.identity, _parent);
            newPillar.SetActive(true);
            newPillar.name = pillarTile.tileObject.name;
            if (!newPillar.TryGetComponent<PlacablePrefab>(out var placeable))
                newPillar.AddComponent<PlacablePrefab>();
            newPillar.transform.localScale = pillarScaler;
            RoofBoltGenerator rb = newPillar.GetComponent<RoofBoltGenerator>();
            ComponentInfo_MineSegment cI_MS = newPillar.GetComponent<ComponentInfo_MineSegment>();
            cI_MS.BoltSpacing = loadedSettings.BoltSpacing;
            if (rb != null)
            {
                rb.RoofBoltSpacing = loadedSettings.BoltSpacing;
                rb.BoltRibOffset = loadedSettings.BoltRibOffset;
                rbGs.Add(rb);
                //rb.GenerateBolts();
            }
            //yield return 0;
            foreach (var gen in rbGs)
            {
                //gen.GenerateBolts();
                //StartCoroutine(DelayedBoltSpawner(gen));
                gen.RoofBoltSpacing = loadedSettings.BoltSpacing;
                gen.BoltRibOffset = loadedSettings.BoltRibOffset;
                SpawnedRoofBoltGenerators.Add(gen);
            }
            //trying to make autoteamstop selection - BDM
            if (newPillar.transform.localScale.z < 1)
            {
                ComponentInfo_MineSegment ms = newPillar.GetComponent<ComponentInfo_MineSegment>();
                if (ms != null)
                {
                    ms.IsTeamstop = false;
                }
            }
        }

        private void MakeEndcap(bool makeNorth)
        {
            // Pick random tile
            MineTile endTile;
            if (makeNorth)
            {
                endTile = loadedTileset.GetRandomNorthEndTile();
            }
            else
            {
                endTile = loadedTileset.GetRandomSouthEndTile();
            }

            Vector3 endcapScaler = new Vector3(loadedSettings.entryWidth / endTile.tileWidth,
                                               loadedSettings.seamHeight / endTile.tileSeamHeight,
                                               1);

            //GameObject newEndcap = Object.Instantiate(endTile.tileObject,
            //                           builderPosition,
            //                           endTile.tileObject.transform.rotation,
            //                           _parent);
            var newEndcap = _loadManager.InstantiateEditorAsset(endTile.TileAsset, null, builderPosition, Quaternion.identity, _parent);
            newEndcap.SetActive(true);
            newEndcap.name = endTile.tileObject.name;
            if (!newEndcap.TryGetComponent<PlacablePrefab>(out var placeable))
                newEndcap.AddComponent<PlacablePrefab>();
            newEndcap.transform.localScale = endcapScaler;
            MineSegment ms;
            if(newEndcap.TryGetComponent<MineSegment>(out ms))
            {
                if (ms.SegmentGeometry.SegmentConnections.Length > 0)
                {
                    float zed = ms.SegmentGeometry.SegmentConnections[0].Centroid.z;
                    newEndcap.transform.Translate(0, 0, -zed);
                }
            }
        }
        #endregion 

        
    }
}
